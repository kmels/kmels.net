public class ArrayQueue implements QueueInterface, java.io.Serializable{	private Object[] queue; // circular array of queue entries (one unusd location)	private int frontIndex;	private int backIndex;	private static final int DEFAULT_MAX_QUEUE_SIZE = 50;	public ArrayQueue()	{		queue = new Object[DEFAULT_MAX_QUEUE_SIZE + 1];		frontIndex = 0;		backIndex = DEFAULT_MAX_QUEUE_SIZE;	} // end default constructor	public ArrayQueue(int initialMaxQueueSize)	{		queue = new Object[initialMaxQueueSize + 1];		frontIndex = 0;		backIndex = initialMaxQueueSize;	} // end constructor			public void enqueue(Object newEntry)	{		if (isFull()) // isFull is private			doubleArray();		backIndex = (backIndex + 1) % queue.length;		queue[backIndex] = newEntry;	} // end enqueue	public Object dequeue()	{		Object front = null;		if (!isEmpty())		{			front = queue[frontIndex];			queue[frontIndex] = null;			frontIndex = (frontIndex + 1) % queue.length;		} // end if		return front;	} // end dequeue	public Object getFront()	{		Object front = null;		if (!isEmpty())			front = queue[frontIndex];		return front;	} // end getFront	public boolean isEmpty()	{		return frontIndex == ((backIndex + 1) % queue.length);	} // end isEmpty	public void clear()	{		// deallocates only the used portion		int x = (backIndex + 1) % queue.length;				for (int frontIndex = 0; frontIndex != x; frontIndex = (frontIndex + 1) % queue.length)			queue[frontIndex] = null;			frontIndex = 0;		backIndex = queue.length -1;	} // end clear	private boolean isFull()	{		return frontIndex == ((backIndex + 2) % queue.length);	} // end isFull	private void doubleArray()	{		Object[] oldQueue = queue;		int oldSize = oldQueue.length;		queue = new Object[2*oldSize];		for (int index = 0; index < oldSize - 1; index++)		{			queue[index] = oldQueue[frontIndex];			frontIndex = (frontIndex + 1) % oldSize;		} // end for		frontIndex = 0;		backIndex = oldSize - 2;	} // end doubleArray}  // end ArrayQueue